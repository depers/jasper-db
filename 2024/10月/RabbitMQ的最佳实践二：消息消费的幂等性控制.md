| title                                      | tags                     | background                                                   | auther | isSlow |
| ------------------------------------------ | ------------------------ | ------------------------------------------------------------ | ------ | ------ |
| RabbitMQ的最佳实践二：消息消费的幂等性控制 | 消息队列/RabbitMQ/Spring | 最近在项目开发中用到了RabbitMQ，其中涉及到的知识点还是比较多的，想通过这篇文章对RabbitMQ开发中涉及到的点进行一个梳理，方便后续工作中借鉴和扩展。这篇文章是这一系列的第二篇文章，我们来讨论消息消费端的幂等性控制。 | depers | true   |

# 概念明确

在这里我讲三个概念，分别是**幂等性**、**防重放**和**防重复点击**。这三个概念都和**重复**有着有着一定的关系。

## 幂等性

### 1. 概念解释

首先我们来看幂等性控制，这里我们一般指的是Web服务中的接口幂等性，在HTTP/1.1中，对幂等性进行了定义。它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外），即第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。

用人话来说就是有一个扣减库存的接口，会将商品的库存减一，如果订单A第一次请求扣减库存后，后面接着多次请求都不再扣减库存了，因为一个订单只会扣减一次库存。如果在这里我们不做幂等性控制，就可能会造成库存被多次扣减的情况。

值得注意的是幂等性和并发控制是两个概念，千万不要混淆。

### 2. 在Web开发中出现幂等性问题的场景

- **前端重复提交表单**： 在填写一些表格时候，用户填写完成提交，很多时候会因网络波动没有及时对用户做出提交成功响应，致使用户认为没有成功提交，然后一直点提交按钮，这时就会发生重复提交表单请求。
- **用户恶意进行刷单**： 例如在实现用户投票这种功能时，如果用户针对一个用户进行重复提交投票，这样会导致接口接收到用户重复提交的投票信息，这样会使投票结果与事实严重不符。
- **接口超时重复提交**：很多时候 HTTP 客户端工具都默认开启超时重试的机制，尤其是第三方调用接口时候，为了防止网络波动超时等造成的请求失败，都会添加重试机制，导致一个请求提交多次。
- **消息进行重复消费**： 当使用 MQ 消息中间件时候，如果发生消息中间件出现错误未及时提交消费信息，导致发生重复消费。

### 3. RestFul API中接口的幂等性

在Restful 推荐的几种 HTTP 接口方法中，分别存在幂等行与不能保证幂等的方法，如下：

| http方法 | 是否幂等         | 解释                                                         |
| :------- | :--------------- | :----------------------------------------------------------- |
| GET      | 是               | GET方法一般用来执行查询操作，不会对系统资源进行变更，所以是**天然幂等**的。 |
| POST     | 否               | PSOT操作一般用于执行新增操作，所以多次执行就会新增多条数据，**不是幂等**的。 |
| PUT      | 需要根据场景区分 | PUT操作一般用于修改操作，修改一般分为更新某个特定字段或是对某个字段进行累加，前者多次执行是**幂等**的，后者则每次修改后的结果都不同，所以**不是幂等**的。 |
| DELETE   | 需要根据场景区分 | DELETE操作一般用于删除操作，删除一般分为按唯一主键删除或是按条件删除，前者多次执行删除操作是**幂等**的，后者如果第一次删除后，有新增了一批数据，再次删除就会导致误删数据，所以**不是幂等**的。 |

### 4. 数据库操作的幂等性

在执行数据库操作时，与RestFul API一样不同的操作在幂等性方面也有着不同的表现，如下：

| 数据库操作 | 是否幂等         | 解释                                                         |
| ---------- | ---------------- | ------------------------------------------------------------ |
| SELECT     | 是               | 不会对业务数据有影响，**天然幂等**。和RestFul API的GET方法一样。 |
| INSERT     | 否               | 多次执行**不能保证幂等性**。和RestFul API的POST方法一样。    |
| UPDATE     | 需要根据场景区分 | 和RestFul API的PUT方法一样。                                 |
| DELETE     | 需要根据场景区分 | 和RestFul API的DELETE方法一样。                              |

### 5. 解决幂等性问题的方法

这里我们再次回顾下幂等性的概念，就是多次请求的效果和第一次请求的效果相同，但是不能对系统造成过多副作用，如何保证除第一次外其余请求不能对系统造成副作用呢，首先我们需要对第一次的请求进行**标记**和**存储**，这样在后续的请求中我们就需要去查询标记，判断是否继续执行请求的操作。

上面提到了两个点，**第一个是标记，标记具有唯一性**，所以生成唯一性标记的方法有很多，下面我提几个思路：

- 根据特定的一个或多个业务字段使用md5生成的token
- 特定的业务字段本身就是唯一的，比如订单的id

大家可以看到上面两个思路用到的都是业务相关字段生成的标记，也有人说直接用uuid不行吗？我觉得直接使用uuid这种随机无状态的标记是有问题的，比如新增一个商品，如果使用uuid来做标记，那么同一个商品就有可能会被新增两次，所以**幂等性的标记必须和业务字段相关才行**。

接着就是**存储，实现存储的方案有很多，最常见的就是数据库和缓存**，比如MySQL和Redis。

明确了上面这两点之后，我们来看具体的应用方案有哪些：

1. **方法一：数据库去重表**

往去重表里插入数据的时候，利用数据库的唯一索引特性，保证唯一的逻辑。唯一序列号可以是一个字段，例如订单的订单号，也可以是多字段的唯一性组合。例如设计如下的数据库去重表。

```SQL
CREATE TABLE `idempotent` (
  `id` int(11) NOT NULL COMMENT 'ID',
  `serial_no` varchar(255)  NOT NULL COMMENT '唯一序列号',
  `source_type` varchar(255)  NOT NULL COMMENT '资源类型',
  `remark` varchar(255)  NOT NULL COMMENT '备注',
  `create_by` bigint(20) DEFAULT NULL COMMENT '创建人',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`)
  UNIQUE KEY `uk_serial_no_source_type` (`serial_no`,`source_type`)  COMMENT '保证业务唯一性'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='幂等性校验表';
```

上表中我们需要重点关注的`serial_no`和`source_type`字段，这里我们使用了数据库的唯一索引来对这两个字段进行存储，其中`serial_no`是特定的一个或多个业务字段使用md5生成的token，而`source_type`字段则是不同的标记类型，比如提交订单、短信消息消费等。

落实到具体的开发层面，我们可以声明一个注解，注解可以这么写：

```Java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Idempotent {
    /**
    * 资源类型
    */
    String sourceType();
    
    /**
    * controller接口的参数，支持SPEL表达式
    */
    String key();
}
```

然后在每个Controller的方法上使用该注解，然后通过Spring AOP切面去拦截该注解，在切面逻辑中通过解析`Idempotent.key`和请求参数，从而得到每条业务数据的参数标识，接着通过md5算法进行摘要，将资源类型和摘要入库，如果入库报`DuplicateKeyException`异常，则表示该业务记录已被处理，这里只需正常返回即可，无需继续下面的流程。

如果入库正常则执行具体的接口逻辑，但是如果接口逻辑执行出现异常，这里就涉及到是否允许用户再次调用。如果允许用户再次调用，接口中需要抛出特定的异常，接着被该切面捕获，接着删除去重表中的这条记录；如果不允许，则接口不要抛出特定的异常，也就不允许用户再次调用。

这种方法是通用的幂等性控制方法，也就是上面的post、put和delete的幂等性问题都可以得到解决。

2. **方法二：Redis去重**

常用的数据存储中，除了数据库就是Redis了，和方法一一样，我们在切面逻辑中可以将数据库入库的动作切换成Redis的`SETNX`操作，`SETNX` 是一个原子性命令，用于设置键值对，但只在键不存在的情况下。它的全称是 "SET if not exists"。这个命令通常用于实现分布式锁或者确保某个值的唯一性。如果键 `key` 不存在，那么 `SETNX` 会设置键 `key` 的值，并返回 `1` 表示操作成功。如果键 `key` 已经存在，那么 `SETNX` 命令不做任何操作，并返回 `0` 表示操作失败。

值得注意的是在Redis中存储数据需要为键值对设置有效时间 ，从而防止内存占用过高，浪费内存的情况。所以这里建议如果针对幂等性控制的键值对应该根据具体的情况来进行设置。

这种方法也是通用的幂等性控制方法，也就是上面的post、put和delete的幂等性问题都可以得到解决。

3. **方法三：乐观锁机制**

乐观锁机制一般用于update更新操作，在乐观锁的设计中，系统假设多个事务或操作可以并发地执行，而不会发生冲突。只有在数据提交更新时，乐观锁才会正式检测数据是否发生了冲突。如果检测到冲突，系统会返回错误信息，让用户决定如何处理这种情况。

乐观锁的实现通常基于两种机制：数据版本（Version）记录机制和CAS（Compare And Swap）算法。这里我们以数据版本记录机制来展开讨论。假设我们有一张这样的数据表：

| id   | name     | price |
| :--- | :------- | :---- |
| 1    | 小米手机 | 1000  |
| 2    | 苹果手机 | 3000  |
| 3    | 华为手机 | 2000  |

为了每次执行更新时防止重复更新，通常都会添加一个 `version` 字段记录当前的记录版本，这样在更新时候将该值带上，那么只要执行更新操作就能确定一定更新的是某个对应版本下的信息。

| id   | name     | price | version |
| :--- | :------- | :---- | :------ |
| 1    | 小米手机 | 1000  | 2       |
| 2    | 苹果手机 | 3000  | 3       |
| 3    | 华为手机 | 2000  | 4       |

假设我们的更新的sql如下，我们需要将小米手机的价格增加50块钱：

```SQL
update my_table set price=price+50, version=version+1 where id=1 and version=2
```

上面 `WHERE` 后面跟着条件 `id=1 AND version=5` 被执行后，`id=1` 的 `version` 被更新为 `6`，所以如果重复执行该条 SQL 语句将不生效，因为 `id=1 AND version=5` 的数据已经不存在，这样就能保住更新的幂等性，多次更新对结果不会产生影响。

在使用这种方法的时候，我们需要将id和version都作为条件传进来，比如在web管理端的查询页面我们就需要将version返回给前端，这样在前端修改数据的时候，就需要前端将version也传回后端。**相比较于前两种办法，实现层面相对复杂且只适用update操作，所以一般不建议使用这种方式。**

4. **方法四：状态机**

状态机这种方式是和业务代码强绑定的，**一般在具体流转状态的业务模型中才会使用**。比如订单模型，它有固定的流转状态，未提交、已提交、待付款、付款成功、付款失败等等状态。

在每一次业务流转的代码逻辑中，我们都先要判断对象的状态，如果状态不符合状态判断，则中断业务流程。比如订单支付接口，我们首先就要判断订单是否已经支付，也就是判断订单的状态是不是待支付，如果不是则任务不能继续支付。

这种方式一般要结合方法一或方法二来配合使用。

# RabbitMQ中消息消费的幂等性控制

# 参考文章

- [简单聊一聊幂等和防重](https://juejin.cn/post/7302805039450292233?searchId=2024100816365224874698A0E01F636BF2)
- [一口气说出四种幂等性解决方案，面试官露出了姨母笑~](https://juejin.cn/post/6906290538761158670?searchId=2024100816365224874698A0E01F636BF2)
- [如何保证 RabbitMQ 的消息可靠性](https://juejin.cn/post/7228864364744507450?searchId=2024100816365224874698A0E01F636BF2)
- [RabbitMQ 可靠性、重复消费、顺序性、消息积压解决方案](https://juejin.cn/post/6977981645475282958?searchId=2024100816365224874698A0E01F636BF2)