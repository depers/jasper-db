| title          | tags         | background                                                   | auther | isSlow |
| -------------- | ------------ | ------------------------------------------------------------ | ------ | ------ |
| 数据的顺序更新 | 数据库/MySQL | 今天在投产的时候遇到一个问题，就是在更新一批数据的时候如何有序的更新 | depers | true   |

假设有这样一张表，表结构如下：

```sql
create table `account_info` (
	`id` bigint not null auto_increment comment '主键',
    `account_no` varchar(20) not null default "" comment '账户号',
    `biz_date` date not null default '1970-01-01' comment '业务日期',
    primary key (`id`),
    unique key `uidx_account_no_and_biz_date` (`account_no`, `biz_date`)
) engine=InnoDB comment '账户表'
```

此时我插入四条记录：

![](../../assert/五条记录.png)

此时我需要更新这四条记录的`biz_date`字段，此时我编写的更新sql是：

```sql
update account_info set biz_date = date_add(biz_date, interval 1 day);
```

执行结果是：

![](../../assert/五条记录更新sql.png)

此时sql是更新是按照id的顺序执行的，因为id=2的这一行数据先更新为002-2024-07-04，但是由于id=3的这条记录已经存在，所以此时会报”**重复记录**“的错误。

接着我们发现如果顺序执行不行，我们可以倒序执行啊，我把sql改成这样：

```sql
update account_info set biz_date = date_add(biz_date, interval 1 day) order by id desc;
```

执行结果是：

![](../../assert/五条记录更新sql-2.png)

此时sql是按照sql倒序执行的，因为id=4这行数据先更新为002-2024-07-03，但是由于id=2这行数据的已经存在的，所以这里会报”**重复记录**“的错误。

接着，我想我是不是可以自己先把执行时间排序之后的id先查出来然后再去更新这块sql是不是就是合理的呢？

```sql
update account_info set biz_date = date_add(biz_date, interval 1 day) 
where id in (select t.id from (select id from account_info order by biz_date desc)as t);
```

首先我们看下子查询的结果，也就是`select t.id from (select id from account_info order by biz_date desc)as t`的结果：

![](../../assert/五条记录更新子查询的结果.png)

值得注意的是这里我用的是`in`，此时执行结果是：

![](../../assert/五条记录更新执行结果.png)

这是为啥啊，之前不是说是以id为顺序进行更新的吗？