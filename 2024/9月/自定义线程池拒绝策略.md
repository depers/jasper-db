| title                | tags                 | background                                                   | auther | isSlow |
| -------------------- | -------------------- | ------------------------------------------------------------ | ------ | ------ |
| 自定义线程池拒绝策略 | Java/并发编程/线程池 | 最近在项目中使用线程池来并发执行任务，从而提高任务执行的效率，但是在开发的过程中，发现总会有任务会莫名的终止，还有就是线程池的拒绝策略该如何使用，采用默认的还是自己实现，通过这篇文章，让我们来一起讨论线程池的使用和需要注意的一些细节。 | depers | true   |

# 线程池拒绝策略的触发时机

这里需要附一张线程池的工作流程图

触发线程池拒绝策略的条件有两个，满足其中一个就会触发拒绝策略

1. 线程池已经被关闭。

    代码演示如下：

2. 任务队列已满且maximumPoolSizes已满。

    代码演示如下：

# JDK默认的拒绝策略

1. **AbortPolicy**：**默认拒绝策略**，抛出异常`RejectedExecutionException`拒绝提交任务

    1. 在线程池已经关闭的情况下使用该拒绝策略会抛出异常，代码演示如下：

    2. 在任务队列已满且maximumPoolSizes已满的情况下使用该拒绝策略

        -   如果在for循环中向线程池添加任务的逻辑不进行异常捕获，程序会卡死，出现这种情况的原因是主线程在提交任务时没有正确处理 RejectedExecutionException，可能会无意中导致主线程阻塞。例如，如果主线程在调用 execute 或 submit 方法时没有捕获异常，那么当触发拒绝策略时，主线程会因为未处理的异常而阻塞。，如下图这样

        -   所以在使用配置了**AbortPolicy**拒绝策略的时候，需要捕获异常，这样就不会造成主线程的阻塞了。代码如下：

        -   还有一种办法就是设置线程工厂时，手动设置线程的异常处理机制，从而实现线程池线程的异常捕获，具体代码如下：

        - ```Java
            @Slf4j
            public class CustomThreadFactory implements ThreadFactory {
            
                private String namePrefix;
                private LongAdder threadNum = new LongAdder();
            
                public CustomThreadFactory(String namePrefix) {
                    this.namePrefix = namePrefix;
                }
            
                @Override
                public Thread newThread(Runnable r) {
                    Thread t = new Thread(r);
                    t.setName(this.namePrefix + "-" + this.threadNum);
                    // 处理线程执行逻辑抛出异常不输出日志到文件的问题
                    t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
                        @Override
                        public void uncaughtException(Thread t, Throwable e) {
                            log.error("线程池线程执行出现异常", e);
                        }
                    });
                    this.threadNum.increment();
                    return t;
                }
            }
            ```

2. **CallerRunsPolicy**：由调用execute方法提交任务的线程来执行这个任务；

    1. **在****线程池****已经关闭的情况下**使用该拒绝策略主线程会接着执行提交到线程池中的任务，代码演示如下：
    2. **在任务队列已满且maximumPoolSizes已满的情况下**使用该拒绝策略，主线程会继续执行被线程池拒绝的消息，代码演示如下：

3. **DiscardPolicy**：直接丢弃新提交的任务；

    1. **在****线程池已经关闭的情况下**使用该拒绝策略被提交到线程池中的任务会被丢弃，代码演示如下：
    2. **在任务队列已满且maximumPoolSizes已满的情况下**使用该拒绝策略，被线程池拒绝的消息会被丢弃，代码演示如下：

4. **DiscardOldestPolicy**：如果执行器没有关闭，队列头的任务将会被丢弃，然后执行器重新尝试执行任务（如果失败，则重复这一过程）；

    1.  在线程池没有被关闭的前提下，**在任务队列已满且maximumPoolSizes已满的情况下**使用该拒绝策略，后面被添加的任务会将之前先加入队列人任务挤走，代码如下所示：

# 任务被提交到线程池，主线程允许阻塞

我们在使用线程池异步处理一批任务的时候，往往会将任务提交到线程池的这一操作，封装在while或是for循环中，这样主线程就会将任务不断地添加到线程池中，代发范式如下：

```Java
for (int i = 0; i < 100; i++) {
    
    executor.execute(() -> {
        // 做一些操作
    })；
}
```

这种情况下一般出现在**批量任务**中，大量的任务就会被提交到线程池，线程池的核心线程数已满的情况下，这些任务会不断的添加到线程池的阻塞队列中，但是阻塞队列的容量是有限的，如果阻塞队列满了且已达到线程池的最大线程数，此时就会触发线程池的拒绝策略。但是在我们的业务逻辑中，我们并不希望我们的任务被拒绝，如果任务出现拒绝，那么我们就要花费额外的精力去人工补偿和维护，那真是太难受了。该怎么解决这个问题呢？

第一种思路：将堵塞队列的容量放大，确保它能够放下足够多的任务。

- 优点
    - 简单，只需要修改参数。
    - 不会阻塞主线程。
- 缺点
    - 占用内存资源过多。
    - 需要根据任务数量的上限来估算，但是即便是这样也有可能会因任务数量过多，导致任务被丢弃，存在生产隐患。

第二种思路：限制主线程添加任务到线程池的速度，不要过快的将所有的任务添加到线程池中。

- 优点
    - 能够保证每一个任务都会被执行，不会被丢弃。
    - 无需制定拒绝策略。
- 缺点
    - 实现先比第一种会复杂点。
    - 会阻塞主线程。

下面我们来着重讨论下第二种思路的实现，我们先来看一段代码：

在上面的代码可以看到，通过Semaphore信号量控制主线程提交任务到线程池中的速度，其中值得注意的是**信号量许可的大小要和线程池最大****线程数****数量保持一致**。这样即便是线程池的阻塞队列满了，因为没有到达最大线程数，所以还可以继续提交任务到线程池中，从而保证每一个任务都可以在线程池中被执行到。

除此之外，需要在异步任务执行之后释放信号量，以便让新的任务被提交执行。因为使用了信号量，所以如果在信号量没有许可的情况下，主线程会被阻塞。

# 任务被提交到线程池，主线程不允许阻塞

除了上面提到的批量提交任务到线程池的这种应用场景外，还有就是在实时性要求比较高的联机交易中，会通过线程池将耗时操作转为异步进行执行。这种情况下，提交任务的主线程是不允许长时间被阻塞的，这种情况下我们的线程池的拒绝策略该如何制定呢？

首先在实时联机交易中做异步处理，我们其实不需要保证我们的异步操作必须要被执行，因为如果执行失败或是异步任务被丢弃，都可以重新发送联机交易进行重试，所以在这种情况下，我们有两种策略：

- 使用`Semaphore`的`tryAcquire(long timeout, TimeUnit unit)`方法，设置获取许可的超时时间，如果超过超时时间就返回异常到前端。
- 不使用Semaphore对提交任务到线程池的速率进行控制，直接提交任务到线程池，对于超过线程池阻塞队列长度且超过最大线程数的任务触发拒绝策略。

其实上面两种方案都是可行的，具体大家可以看自己的使用场景决定。