> Redis/面试

> 整理一些关于Redis的面试问题

<img src="../../assert/Redis_Logo.svg" align=center/>

1. 针对Redis中热点数据的缓存怎么处理？

    > 当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的SQL、多次IO、多个依赖等在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。

    **方案一：互斥锁（mutex）**，只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据。

    * **具体逻辑**

        1）从Redis获取数据，如果值不为空，则直接返回值；否则执行下面的2.1）和2.2）步骤   
            2.1）如果set（nx和ex）结果为true，说明此时没有其他线程重建缓存， 那么当前线程执行缓存构建逻辑。  
            2.2）如果set（nx和ex）结果为false，说明此时已经有其他线程正在执行构建缓存的工作，那么当前线程将休息指定时间（例如这里是50毫秒，取决于构建缓存的速度）后，重新执行函数，直到获取到数据。

        > Redis 的 set 命令允许将键值对存储在 Redis 中。其中，参数 nx 和 ex 可用于控制键值对的存储。
        >
        > nx 参数表示当键不存在时才执行 set 操作。如果键已经存在，则不执行 set 操作并返回错误信息。
        >
        > ex 参数表示设置键的过期时间，单位为秒。如果键在指定时间内未被访问，则 Redis 会自动删除该键。
        >
        > 示例：
        >
        > ```shell
        > 127.0.0.1:6379> set key value nx ex 10
        > OK
        > ```
        >
        > 这个例子中，将 key 和 value 设置为键值对，并在键不存在时才执行 set 操作，并设置键的过期时间为10s。

    * **优缺点**

        如果构建缓存过程出现问题或者时间较长，可能会存在**死锁和线程池阻塞的风险**，但是这种方法能够较好地降低后端存储负载，并在**一致性上做得比较好**。

    **方案二：永远不过期**，设置热点数据的缓存为永不过期。

    * **具体逻辑**

        从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期 后产生的问题，也就是“物理”不过期。

        从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会**使用单独的线程去构建缓存**。

    * **优缺点**

        由于没有设置真正的过期时间，实际上已经**不存在热点key产生的一系列危害**，但是会存在**数据不一致的情况**，同时代码复杂度会增大。

    **问题：怎么知道哪些数据是热点数据？因为本地缓存资源有限，不可能把所有的商品数据进行缓存，它只会缓存热点的数据。那怎么知道数据是热点数据呢？**

    利用redis4.x自身特性，**LFU机制**发现热点数据。实现很简单，只要把redis内存淘汰机制设置为`allkeys-lfu`或者`volatile-lfu`方式，再执行`./redis-cli --hotkeys`会返回访问频率高的key，并从高到底的排序,在设置key时，需要把商品id带上，这样就是知道是哪些商品了。
    
1. 更新Redis和MySQL时的数据一致性问题

    在更新Redis和MySQL数据的时候，存在以下几种情况：

    * 先更新数据库，后更新Redis

        请求A和B同时请求过来，请求A更新数据为2，请求B更新数据为3。请求A先更新数据库，请求B先更新数据库，请求B先更新缓存，请求A后更新缓存。此时数据库数据为3，缓存数据为2，数据不一致。

    * 先更新Redis，后更新数据库
    
        请求A和B同时请求过来，请求A更新数据为2，请求B更新数据为3。请求A先更新缓存，请求B先更新缓存，请求B先更新数据库，请求A后更新数据库。此时缓存数据为3，数据库数据为2，数据不一致。

    上面讲到的两种情况都不能很好的解决数据更新的问题，接下来我们讨论另外的一种策略。
    
    **Cache Aside 策略**，中文是叫旁路缓存策略。该策略又分为写策略和读策略。
    
    ![](../../assert/旁路策略.webp)
    
    **写策略的步骤：**
    
    - 先更新数据库中的数据，再删除缓存中的数据。
    
    **读策略的步骤：**
    
    - 如果读取的数据命中了缓存，则直接返回数据；
    - 如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。

    策略分析：

    * 先删除Redis中的缓存，后更新数据库

        读请求A和写请求B同时过来，目前数据库的数据是1，写请求要将其修改为2。此时请求B先删除了缓存，接着请求A发现缓存不存在，就将数据库数据1读出并重新缓存，最后请求B将数据2更新到数据库。此时缓存数据为1，数据库存储数据为2。

    * 先更新数据库中的数据，后删除Redis中的缓存

        写请求A和读请求B同时过来，目前数据库的数据是1，写请求要将其修改为2。此时请求B先请求缓存，发现缓存不存在，就会将数据库中的1读出来。接着请求A先修改数据库中的数据为2，更新到数据库中，此时数据库是1，然后删除缓存。最后请求B数据1缓存到缓存中。此时存在不一致。

        但是上面说到的这种情况是很少见的，因为请求B从数据库中读取到1后，写入缓存的速度是远远快于请求A数据库的操作，所以**先更新数据库中的数据，后删除Redis中的缓存是可以保证缓存一致性的**。

    除了上面讲到的这一点外，在进行数据缓存时一定要**保证互斥性**；第二缓存的数据一定要**加有效时间**。

# 参考文章

* [这些年背过的面试题——Redis篇](https://mp.weixin.qq.com/s/8-Lf5KiyclW77uQwrYDTCw)