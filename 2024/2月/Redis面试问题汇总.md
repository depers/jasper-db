> Redis/面试

> 整理一些关于Redis的面试问题

![](../../assert/Redis_Logo.svg)

1. 针对Redis中热点数据的缓存怎么处理？

    > 当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的SQL、多次IO、多个依赖等在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。

    **方案一：互斥锁（mutex）**，只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据。

    * **具体逻辑**

        1）从Redis获取数据，如果值不为空，则直接返回值；否则执行下面的2.1）和2.2）步骤
            2.1）如果set（nx和ex）结果为true，说明此时没有其他线程重建缓存， 那么当前线程执行缓存构建逻辑。
            2.2）如果set（nx和ex）结果为false，说明此时已经有其他线程正在执行构建缓存的工作，那么当前线程将休息指定时间（例如这里是50毫秒，取决于构建缓存的速度）后，重新执行函数，直到获取到数据。

        > Redis 的 set 命令允许将键值对存储在 Redis 中。其中，参数 nx 和 ex 可用于控制键值对的存储。
        >
        > nx 参数表示当键不存在时才执行 set 操作。如果键已经存在，则不执行 set 操作并返回错误信息。
        >
        > ex 参数表示设置键的过期时间，单位为秒。如果键在指定时间内未被访问，则 Redis 会自动删除该键。
        >
        > 示例：
        >
        > ```ruby
        > ruby
        > 复制代码127.0.0.1:6379> set key value nx ex 10
        > OK
        > ```
        >
        > 这个例子中，将 key 和 value 设置为键值对，并在键不存在时才执行 set 操作，并设置键的过期时间为10s。

    * **优缺点**

        如果构建缓存过程出现问题或者时间较长，可能会存在**死锁和线程池阻塞的风险**，但是这种方法能够较好地降低后端存储负载，并在**一致性上做得比较好**。

    **方案二：永远不过期**，设置热点数据的缓存为永不过期。

    * **具体逻辑**

        从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期 后产生的问题，也就是“物理”不过期。

        从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会**使用单独的线程去构建缓存**。

    * **优缺点**

        由于没有设置真正的过期时间，实际上已经**不存在热点key产生的一系列危害**，但是会存在**数据不一致的情况**，同时代码复杂度会增大。

    **问题：怎么知道哪些数据是热点数据？因为本地缓存资源有限，不可能把所有的商品数据进行缓存，它只会缓存热点的数据。那怎么知道数据是热点数据呢？**

    利用redis4.x自身特性，**LFU机制**发现热点数据。实现很简单，只要把redis内存淘汰机制设置为`allkeys-lfu`或者`volatile-lfu`方式，再执行`./redis-cli --hotkeys`会返回访问频率高的key，并从高到底的排序,在设置key时，需要把商品id带上，这样就是知道是哪些商品了。