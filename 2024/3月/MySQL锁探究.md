| title         | tags          | background                                                   | auther | isSlow |
| ------------- | ------------- | ------------------------------------------------------------ | ------ | ------ |
| MySQL锁探究一 | MySQL/锁/事务 | 最近在研究基于数据库实现分布式序列号生成方案时发现，自己对MySQL这块锁的理解还停留在理论和简单使用的层面，并没与在实践中充分的掌握这块知识点，所以这里专门开一篇文章来讨论这块内容。 | depers | true   |

# 全局锁

1. 使用

    给数据库添加全局锁：

    ```sql
    flush tables with read lock
    ```

    解除全局锁：

    ```sql
    unlock tables
    ```

2. 作用：使整个数据库处于只读状态。

3. 使用场景：做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

4. 全局锁的缺点：如果为整个数据库添加了全局锁，所有业务的数据库操作都会被阻塞，影响生产环境的正常运转。

5. 数据备份的最佳实践：

    在**可重复读的隔离级别下**，在**备份数据库之前先开启事务**，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。

# 表级锁

## 表锁

### 共享锁

* 读锁，允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。
* 加锁命令：`LOCK TABLES t READ`

### 排他锁

* 写锁，允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。
* 加锁命令：`LOCK TABLES t WRITE`

### MDL锁

* 元数据锁

* 加锁逻辑

    * 不需要显示的使用 MDL，在数据库操作时自动添加；
    * 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
    * 对一张表做结构变更操作的时候，加的是 **MDL 写锁**；

* 作用：MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。

* 特殊情况：**无法申请到MDL写锁**

    **场景描述**：

    1. 线程A开启事务，对表进行了查询操作，但是不提交，此时获取了MDL读锁。
    2. 线程B开启事务，对表进行了查询操作，然后提交，此时获取了MDL读锁，但是读读不阻塞，所以能够顺利执行。
    3. 线程C开启事务，修改表的一个字段，此时因为线程A的事务没有提交，所以事务C无法获取MDL写锁，导致线程C阻塞。
    4. 在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。

    **原因解释**：

    因为申请 MDL 锁的操作会形成一个队列，队列中**写锁获取优先级高于读锁**，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

    所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了MDL读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。

## 意向锁

作用：**意向锁的目的是为了快速判断表里是否有记录被加锁；否则就要全表遍历，十分损耗性能**。

### 意向共享锁

* 加锁逻辑：在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」。

* 具体场景：

    1. 普通的select操作因为MVCC是不加锁的。

    2. 显示给记录添加共享锁

    ```sql
    -- 先在表上加上意向共享锁，然后对读取的记录加共享锁
    select ... lock in share mode;
    ```

### 意向排他锁

* 加锁逻辑：在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」。

* 具体场景：

    1. 当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。

    2. 显示给记录添加独占锁

    ```sql
    -- 先表上加上意向独占锁，然后对读取的记录加独占锁
    select ... for update;
    ```

### 值得注意

1. 意向锁是表锁，不会和行级锁产生冲突。
2. 意向锁之间也不会产生冲突，也就是说对同一张表添加意向读锁和意向写锁是兼容的。
3. **意向锁会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突**。

## AUTO-INC锁

作用：保证使用声明 `AUTO_INCREMENT` 属性主键的顺序递增。

### 传统的AUTO-INC锁

* 加锁逻辑：
    1. AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是**在执行完插入语句后就会立即释放**。
    2. 在插入数据时，会加一个**表级别的 AUTO-INC 锁**，然后为被`AUTO_INCREMENT`修饰的字段赋值递增的值，等插入语句执行完成后，才会把AUTO-INC锁释放掉。
    3. 一个事务在持有 AUTO-INC 锁的过程中，其他事务的**如果要再向该表插入语句都会被阻塞**，从而保证插入数据时，被 `AUTO_INCREMENT` 修饰的字段的值是连续递增的。

* 缺点：AUTO-INC 锁在对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。

### 轻量级的AUTO-INC锁

* 加锁逻辑：在插入数据的时候，**会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁**。

### 如何设置AUTO-INC锁

InnoDB 存储引擎提供了`innodb_autoinc_lock_mode`的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。

- 当`innodb_autoinc_lock_mode = 0`，**传统锁定模式**，就采用原来的AUTO-INC锁，语句执行结束后才释放锁。
- 当`innodb_autoinc_lock_mode = 1`，**连续锁定模式**：
    - 普通 insert 语句，自增锁在申请自增主键之后就马上释放，并不需要等语句执行后才释放。
    - 类似`insert … select`这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放。
- 当`innodb_autoinc_lock_mode = 2`，**交错锁定模式**，就采用轻量级AUTO-INC锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。

### 交错锁定模式下，主从复制导致数据不一致的问题

`binlog_format` 的值决定了 Binlog 中记录数据变更的方式，主要有三种模式：`STATEMENT`、`ROW` 和 `MIXED`。

* 在 `STATEMENT` 模式下，MySQL 会以**语句级**的方式记录 Binlog。也就是说，Binlog 中记录的是执行的 SQL 语句本身，而不是数据变更的具体内容。
* 在 `ROW` 模式下，MySQL 会以**行级**的方式记录 Binlog。也就是说，Binlog 中记录的是每一行数据的变更，包括修改前后的数据值。
* `MIXED` 模式是 `STATEMENT` 和 `ROW` 模式的混合模式。MySQL 会根据执行的 SQL 语句自动选择记录方式：
    - 如果 MySQL 认为语句是确定性的，则以 `STATEMENT` 模式记录。
    - 如果 MySQL 认为语句是非确定性的，则以 `ROW` 模式记录。

解决方案：**当`innodb_autoinc_lock_mode = 2`时，并且`binlog_format = row`，既能提升并发性，又不会出现数据一致性问题**。

# 行级锁

## 记录锁

Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：

- 当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;
- 当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。

值得注意的是：

* 记录锁一般锁的是**唯一索引列字段**。
* 对于添加了X型记录锁的一条记录来说，是无法删除和更新该条记录的。

## 间隙锁

**间隙锁（Gap Lock）** 锁定的是索引记录之间的间隙，或者第一个索引记录之前或最后一个索引记录之后的"间隙"。它阻止其他事务在这个间隙中插入新记录，但不阻止其他事务获取同一间隙上的间隙锁。

### 特点

- **仅存在于可重复读（REPEATABLE READ）隔离级别**：在读已提交（READ COMMITTED）隔离级别下，InnoDB 不会使用间隙锁
- **只针对非唯一索引**：对于唯一索引的等值查询，InnoDB 会退化为记录锁
- **可以共存**：不同事务可以在同一个间隙上持有兼容的间隙锁
- **与插入意向锁冲突**：间隙锁会阻塞插入意向锁
- **锁定范围**：索引记录之间的**开区间**（例如 `(10, 20)` 表示大于10且小于20的所有值）
- **作用**：阻止其他事务在锁定间隙内插入新记录，防止幻读

## 临键锁

Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身，就是说他同时具备Record Lock和Gap Lock的功能。

临建锁锁定的范围是一个列的左开右闭区间，意味着无法在此区间插入数据，且无法删除和更新锁定的记录。

临建锁是一个X型锁。

## 插入意向锁

插入意向锁是一种在插入行之前由 INSERT 操作设置的间隙锁。此锁以某种方式发出插入意向信号，使得插入同一索引间隙的多个事务（如果它们不是在间隙内的同一位置插入）无需相互等待。假设索引记录的值为 4 和 7。尝试插入值 5 和 6 的独立事务在获得插入行的排他锁之前，各自使用插入意向锁锁定 4 和 7 之间的间隙，但由于这些行不冲突，因此不会相互阻塞。

### 特点

- 插入意向锁是 **InnoDB 引擎** 在 **可重复读（RR）隔离级别** 下，**插入新记录前** 自动获取的一种 **轻量级间隙锁**（Gap Lock 的子类型）。
- 仅与 **其他间隙锁（Gap Lock）** 互斥
- 多个事务可同时持有同一间隙的插入意向锁（互相不冲突）
- 目的是防止 **幻读** 的同时，**最大化并发插入性能**

# 参考文章

* [小林code-锁](https://xiaolincoding.com/mysql/lock/mysql_lock.html#%E5%85%A8%E5%B1%80%E9%94%81)
* [AUTO_INCREMENT Handling in InnoDB](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html)
* [从根上理解MySQL-第25章 工作面试老大难-锁](https://relph1119.github.io/mysql-learning-notes/#/mysql/25-工作面试老大难-锁?id=第25章-工作面试老大难-锁)

