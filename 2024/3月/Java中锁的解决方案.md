> Java/线程安全/分布式锁

> 最近在做项目的时候发现了很多使用锁的场景，这里针对这部分内容做一个总结和归纳。

# 锁的作用

锁（Lock）是一种同步机制，用于多线程编程中对共享资源的访问控制。它的主要作用是确保在任何给定的时间只有一个线程能够访问被保护的共享资源。

主要解决的问题有：

* **实现线程安全**，所谓线程安全指的是**当多个线程访问某个类时，不管运行时环境采取的是何种调度方式或者这些线程将如何交替运行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的**。
* **防止竞态条件**，所谓竞态条件指的是**在都多线程环境下，由于线程的交替执行的顺序不同，从而导致了不同的结果**。我们称这种情况为竞态条件，最常见的竞态条件类型就是**先检查后执行**，也就是说检查结果的不同就会得到不同的执行情况（比如银行转账，对象实例化）。还有一种常见的竞态条件是在计数操作中存在“**读取-修改-写入**”（比如一个计数器）。

# 锁的类型

* 互斥锁
* 读写锁
* 自旋锁
* 递归锁（可重入锁）
* 信号量
* 条件变量

# Java中锁的解决方案

* 使用JDK提供的原子类
* 使用Synchronized关键字（可重入）
* 使用ReentrantLock（可重入）

# 分布式锁的优缺点讨论

* 基于数据库实现的分布式锁
  * 优点
    1. 实现简单，不需要引入第三方组件。
  * 缺点
    1. 性能较差：在高并发场景下对数据库的压力比较大。
    2. 不支持锁超时：需要通过应用程序层面来处理锁的超时问题。
* 基于Redis实现的分布式锁
  * 优点
    1. 性能高：Redis是一个高性能的缓存服务。
    2. 支持超时：Redis支持锁的超时设置，可以避免死锁问题。
  * 缺点
    * 单点故障：虽然Redis本身是一个高可用的分布式系统，但是如果Redis集群中的一个节点出现故障，可能会导致整个系统不可用。
    * 不支持锁的重入性：Redis不支持锁的重入性，需要在应用程序层面进行处理。
    * 可能会出现锁的超时问题：如果锁的超时时间设置的不合理，可能会导致锁超时的问题。
  * 实现方式
    1. 基于Redisson实现的分布式锁
    2. 基于Lua+Redis实现分布式锁
  * 实践：[RedisLock.java](https://github.com/depers/new-mall/blob/third-stage_distributedArchitecture/distribute/lock-demo/src/main/java/cn/bravedawn/demo/lock/RedisLock.java)
  * 最佳实践：使用Redisson作为Redis客户端
* 基于Zookeeper实现的分布式锁
  * 优点
    1. 可靠性高：Zookeeper本身就是一个高可用的分布式系统，可以保证分布式锁的可靠性。
    2. 支持超时：Zookeeper支持锁的超时设置，可以避免死锁问题。
  * 缺点
    1. 单点故障：虽然Zookeeper本身是一个高可用的分布式系统，但是如果Zookeeper集群中的一个节点出现故障，可能会导致整个系统不可用。
    2. 不支持锁的重入性：Zookeeper不支持锁的重入性，需要在应用程序层面进行处理。
  * 实践：[ZkLock.java](https://github.com/depers/new-mall/blob/third-stage_distributedArchitecture/distribute/lock-demo/src/main/java/cn/bravedawn/demo/lock/ZkLock.java)
  * 最佳实践：使用curator作为ZK的客户端实现分布式锁

# Redis实现分布锁的坑

1. **获取锁不是原子操作**

    **问题描述**：就是说我们不能先set key，然后再对key进行expire，这里存在并发问题。

    **解决办法**：采用`set <key> <value> EX <exipreTime> NX` ，一条执行语句去做。

2. **忘记释放锁**

    **问题描述**：我们按照`set ex nx`的方式获取到了锁，但是我们如果忘记及时的释放锁，那么其他线程就会被阻塞导致请求失败。

    **解决办法**：更好用的解决方案是采用如下的加锁方案，还有一点就是一定要给锁设置有效时间：

    ```java
    try {
      if (lock.getLock()) {
      // 业务逻辑
    	}
    } catch(Throwable e) {
      // 处理异常
    } finally{
      lock.unlock();
    }
    ```

3. **释放了别人的锁**

    **问题描述**：比如存在一种场景，线程A获取到了商品1的锁，但是由于某些原因线程A被阻塞住了，线程A对商品1的锁过期了；此时线程B获取到了商品1的锁，接着线程A执行完了自己的逻辑，线程A此时去释放商品的锁释放的是线程B加的锁。

    **解决办法**：

    * 我们在设置锁的可以在value里面设置一个requestId（可以使用UUID，全局唯一即可），在释放锁的时间需要获取到该锁的值（也就是之前设置的requestId），然后判断和之前设置的值是否相同，如果相同才允许删除锁，返回成功。
    * 使用Lua脚本执行释放锁的操作，Lua脚本能保证查询锁是否存在和删除锁是原子操作。

4. **大量失败请求**

    **问题描述**：如果两个请求的逻辑中同时去创建相同的一个目录，比如20240324这个目录。这里如果使用了分布式锁，第一个请求获取了锁创建了目录并返回了成功，第二个请求由于没有获取到锁我们直接返回失败是有问题的。

    **解决办法**：这里使用**自旋锁**来解决这个问题，在一个死循环中，如果没有获取到锁就等待一段时间，然后再去获取锁，如果到了超时时间还没有获取到锁，就直接返回失败。

5. **锁重入问题**

    **问题描述**：比如我们要获取一个菜单树或是分类树，肯定是根据一个根目录去递归查询的，如果这个菜单数据是个热点数据，为了保证在并发条件下可以读取到最新的数据，这里我们通过redis分布式锁区做竞态条件的控制。这里需要明确的是获取菜单数的逻辑是一个递归算法，也就是说我们在获取第一层菜单的时候加了锁，然后获取第二层菜单的时候还要加锁，按照我们之前的设计使用`set nx`在这里就无法获取到锁了。

    **解决办法**：使用可重入锁，在Redisson的可重入锁的实现中，当锁名和requestId一致时会做一个计数加1的操作，其中锁名时key，requestId是field，value是计数值。我们要保证锁的加锁次数和锁的释放次数是一致的，这样菜单完全的释放锁。

6. **性能问题**

    * **读写锁**：适用写少读多的场景，读与读是共享的，不互斥；读与写互斥；写与写互斥。
    * **锁分段**：锁分段，如果同时并发有一万个请求过来，同时获取一个商品的锁，那同一时间只有一个请求可以获取到，9999个请求都失败了，这个是不是有问题？这就变成均匀分布的秒杀了。比如1000个商品，我们将其分为100段，每段十个库存，如果收到一个请求，我们首先会计算用户id的hash值，然后用100取模，接着模为1的去第一段库存进行扣减，模为2的去第二段库存进行扣减，依次类推，这样在多线程环境中就可以减少锁的冲突，等待锁的线程减少了，从而系统的吞吐量也提高了。但是这样做也存在一些问题：路由算法、跨段统计库存等，会增加系统设计的复杂度。

7. **锁的超时时间**

    **问题描述**：因执行业务代码耗时过长，超过了锁的有效时间，从而导致锁释放。这时别的线程就会获取到锁，访问了临界资源就会导致数据异常的情况，无法保证互斥性。

    **解决办法**：

    * 可以使用`TimeTask`类给锁自动续期，开启一个定时任务，每隔10秒钟自动刷新一次过期时间。
    * 上面提到到这种机制在Redisson中叫做看门狗（Watch Dog）。

8. **主从复制的问题，Master节点挂了分布式锁失效**

    **问题描述**：如果Redis存在多个实例，比如在做了主从或是使用了哨兵模式，基于Redis分布式锁的功能就会出现问题。假设Redis使用了主从模式，1个master节点和3个slave节点，master节点负责写数据，slave节点负责读数据。Redis的加锁操作是在master节点上进行的，加锁成功后再异步同步给所有的slave节点。如果某一天master节点因为某些原因挂掉了，这样就需要找一个slave节点升级为新的master节点，与此同时有一个锁A刚刚加锁成功，master节点就挂掉了，此时一个slave节点被选举为新的master节点，这样就导致锁A的数据因未能及时同步而丢失。后面如果有新的线程给锁A加锁就会成功，此时分布式锁就不起作用了。

    **解决办法**：Redisson中提供了`RedissonRedLock`类，实现了Redlock算法，该算法的思路如下：应用程序去多个Redis实例获取锁，如果获取锁的实例数大于`N/2+1`（N指的是Redis的实例数）且没有超过最大等待时间，则认为获取所成功，否则获取锁失败。综上可以看出使用`RedissonRedLock`增加了额外的时间成本，有点得不偿失，在实际业务中使用的并不多。

9. **CAP问题**

    在分布式环境中，如果你的实际业务场景更需要保证数据一致性，应该使用**CP类型**的分布式锁，比如**基于Zookeeper实现的分布式锁**，性能可能没有那么好，但是数据一般不会丢。

    如果实际业务中需要保证数据的高可用，应该使用**AP类型**的分布式锁，比如**基于Redis的分布式锁**，它是基于内存的，性能比较好，但是会有丢失数据的风险。
