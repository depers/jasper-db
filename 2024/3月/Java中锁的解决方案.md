> Java/线程安全/分布式锁

> 最近在做项目的时候发现了很多使用锁的场景，这里针对这部分内容做一个总结和归纳。

# 锁的作用

锁（Lock）是一种同步机制，用于多线程编程中对共享资源的访问控制。它的主要作用是确保在任何给定的时间只有一个线程能够访问被保护的共享资源。

主要解决的问题有：

* **实现线程安全**，所谓线程安全指的是**当多个线程访问某个类时，不管运行时环境采取的是何种调度方式或者这些线程将如何交替运行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的**。
* **防止竞态条件**，所谓竞态条件指的是**在都多线程环境下，由于线程的交替执行的顺序不同，从而导致了不同的结果**。我们称这种情况为竞态条件，最常见的竞态条件类型就是**先检查后执行**，也就是说检查结果的不同就会得到不同的执行情况（比如银行转账，对象实例化）。还有一种常见的竞态条件是在计数操作中存在“**读取-修改-写入**”（比如一个计数器）。

# 锁的类型

* 互斥锁
* 读写锁
* 自旋锁
* 递归锁（可重入锁）
* 信号量
* 条件变量

# Java中锁的解决方案

* 使用JDK提供的原子类
* 使用Synchronized关键字（可重入）
* 使用ReentrantLock（可重入）

## 分布式锁的优缺点讨论

* 基于数据库实现的分布式锁
  * 优点
    1. 实现简单，不需要引入第三方组件。
  * 缺点
    1. 性能较差：在高并发场景下对数据库的压力比较大。
    2. 不支持锁超时：需要通过应用程序层面来处理锁的超时问题。
* 基于Redis实现的分布式锁
  * 优点
    1. 性能高：Redis是一个高性能的缓存服务。
    2. 支持超时：Redis支持锁的超时设置，可以避免死锁问题。
  * 缺点
    * 单点故障：虽然Redis本身是一个高可用的分布式系统，但是如果Redis集群中的一个节点出现故障，可能会导致整个系统不可用。
    * 不支持锁的重入性：Redis不支持锁的重入性，需要在应用程序层面进行处理。
    * 可能会出现锁的超时问题：如果锁的超时时间设置的不合理，可能会导致锁超时的问题。
  * 实现方式
    1. 基于Redission实现的分布式锁
    2. 基于Lua+Redis实现分布式锁
  * 实践：[RedisLock.java](https://github.com/depers/new-mall/blob/third-stage_distributedArchitecture/distribute/lock-demo/src/main/java/cn/bravedawn/demo/lock/RedisLock.java)
  * 最佳实践：使用Redission作为Redis客户端
* 基于Zookeeper实现的分布式锁
  * 优点
    1. 可靠性高：Zookeeper本身就是一个高可用的分布式系统，可以保证分布式锁的可靠性。
    2. 支持超时：Zookeeper支持锁的超时设置，可以避免死锁问题。
  * 缺点
    1. 单点故障：虽然Zookeeper本身是一个高可用的分布式系统，但是如果Zookeeper集群中的一个节点出现故障，可能会导致整个系统不可用。
    2. 不支持锁的重入性：Zookeeper不支持锁的重入性，需要在应用程序层面进行处理。
  * 实践：[ZkLock.java](https://github.com/depers/new-mall/blob/third-stage_distributedArchitecture/distribute/lock-demo/src/main/java/cn/bravedawn/demo/lock/ZkLock.java)
  * 最佳实践：使用curator作为ZK的客户端实现分布式锁

# Redis实现分布锁的坑

1. 获取锁不是原子操作

    问题：就是说我们不能先set key，然后再对key进行expire，这里存在并发问题。

    解决办法：采用`set <key> <value> EX <exipreTime> NX` ，一条执行语句去做。

2. 忘记释放锁

    问题：我们按照`set ex nx`的方式获取到了锁，但是我们如果忘记及时的释放锁，那么其他线程就会被阻塞导致请求失败。

    解决办法：更好用的解决方案是采用如下的加锁方案：
    ```java
    try {
      if (lock.getLock()) {
      // 业务逻辑
    	}
    } catch(Throwable e) {
      // 处理异常
    } finally{
      lock.unlock();
    }
    
    ```

3. 释放了别人的锁

    问题：比如存在一种场景，线程A获取到了商品1的锁，但是由于某些原因线程A被阻塞住了，线程A对商品1的锁过期了；此时线程B获取到了商品1的锁，接着线程A执行完了自己的逻辑，线程A此时去释放商品的锁释放的是线程B加的锁。

4. 大量失败请求

    问题：如果同时并发有一万个请求过来，同时获取一个商品的锁，那同一时间只有一个请求可以获取到，9999个请求都失败了，这个是不是有问题？变成了请求均匀的并发请求了

    解决办法：自旋锁

5. 锁重入问题

    问题：比如我们要获取一个菜单树或是分类数，肯定是根据一个根目录去递归查询的，如果这个菜单是个热点数据

    解决办法：可重入锁

6. 性能问题

    * 读写锁，写少读多
    * 锁分段，锁分段，比如1000个商品，我们将其分为100段，每段十个库存
        * 存在的问题：路由问题、跨段统计库存

7. 锁的超时时间

    问题：因执行业务代码耗时过长，超过了锁的有效时间。那么别的线程
