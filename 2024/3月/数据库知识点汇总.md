> 面试/数据库/MySQL

> 整理数据库相关的问题的汇总。

<div align=center><img src="../../assert/MySQL.png" style="zoom: 50%;" /></div>

1. 数据库设计的三大范式是什么？

    1. 每一列字段不可再分（也可以说成原子性）。
    2. 确保表中每列与主键相关。
    3. 一个属性不依赖于其他非主键属性，也就是说没有依赖传递。

2. MySQL使用**索引**查询数据库，最多会触达几次磁盘IO？

    在 MySQL 中，使用索引查询数据库时，最多会触达**两次磁盘 IO**。

    **第一次磁盘 IO 是在索引文件中查找符合查询条件的索引项**。索引文件通常是存储在磁盘上的 B 树结构，通过索引的有序性，可以快速定位到符合查询条件的索引项。

    **第二次磁盘 IO 是在数据文件中获取对应的数据行**。根据索引项中存储的指向数据行的指针，MySQL 可以直接定位到数据文件中的对应位置，读取所需的数据行。

3. MySQL中索引失效的原因有哪些？

    1. **`LIKE`以`%`或者`_`开头**，则不走索引。

    2. **`OR`语句前后没有同时使用索引**，当OR 左右查询字段只有一个是索引，该索引失效，只有当OR 左右查询字段均为索引时，才会生效。

    3. **联合索引没遵循最左匹配原则**。

    4. **索引列数据类型出现隐式转化**。

        varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。例如：tb1表中name字段是字符串类型

        ```sql
        索引失效：SELECT * FROM tb1 WHERE name = 123
        索引有效：SELECT * FROM tb1 WHERE name = '123'
        ```

    5. **对索引列进行计算或使用函数**。

        比如：

        ```sql
        SELECT * FROM t WHERE id*3=3000
        SELECT * FROM t WHERE ABS(id)=3000
        ```

    6. **ORDER BY使用错误**

        前提：假设建立索引`key a_b_c(a,b,c)`

        * `ORDER BY`的索引优化

            * `order by` 能使用最左前缀原则（以下四种情况索引生效）：

                - `order by a`

                - `order by a,b`

                - `order by a,b,c`

                - `order by a desc,b desc,c desc`

        * `WHERE` + `ORDER BY`的索引优化

            * 如果`where`+`order by`符合最左前缀原则，则索引生效
                - `where a=1 order by b,c`
                - `where a=1 and b=2 order by c`
                - `where a=1 and b>2 order b,c`

            * 以下情况索引失效：
                - `order by a asc,b desc,c desc`	// 排序不一致
                - `where d=1 order by b,c` 	           // 丢失a索引
                - `where a=1 order c `                              // 丢失b索引
                - `where a>1 order b,c`                          // 范围之后失效
                - `where a in (1,2,3..) order by b, c` // 范围查询之后失效

    7. **全表扫描速度比索引速度快**

        此时mysql会使用全表扫描，索引失效。例如：

        * 数据量极少的表

        * 表中索引字段数据重复率太高

4. 关于Limit分页查询的优化

    方法一：采用内连接查询，在驱动表中通过对主键进行分页查询，之后再通过主键去查询其他列的数据。这里我直接通过sql来进行演示：
    ```sql
    select order_id, order_no, order_status, order_price
    	from order
    	innor join (select order_id from order limit 10000, 20) using (order_id);
    ```

    方法二：保存上一次分页查询的最后一条记录的id，在第二次进行分页查询的时候利用主键索引直接过滤limit之前的数据。

    ```sql
    select order_id, order_no, order_status, order_price
    	from order
    	where order_id > 10000 # 上次查询时记录的最后一条记录的id
    	order by id 
    	limit 10000, 20
    ```

5. B树和B+树的区别是什么？或者说B+树的优势在哪里？

    1. B+树只在叶子节点存储数据，就可以腾出更多的空间让分支节点组织一棵更宽的树，树高就会更低，所以就可以让我们更快速的检索记录。而B树叶子节点和非叶子节点都会存储数据。
    2. B+树的相邻叶子节点之间采用了双向链表，一个节点可以快速的定位下一个节点，所以B+树是支持范围查询和排序的。

6. 关联查询的SQL优化

    * 外连接查询中，首先会查驱动表的数据，然后遍历驱动表的每一条数据去被驱动表去查数据，此时被驱动表在`on`条件上的字段必须加索引。

7. redo、undo、binlog日志分别是做什么的？

    * redo日志：又叫重做日志，是 Innodb 存储引擎层生成的日志，实现了事务中的**持久性**，主要**用于掉电等故障恢复**。
    * undo日志：又叫回滚日志，是 Innodb 存储引擎层生成的日志，实现了事务中的**原子性**，主要**用于事务回滚和 MVCC**。
    * binlog：又叫归档日志，是 Server 层生成的日志，主要**用于数据备份和主从复制**。

8. MVCC是什么？具体的实现原理是什么？

    MVCC，Multi-Version Concurrency Control ，多版本并发控制）指的就是在**使用`READ COMMITTD`、`REPEATABLE READ`这两种隔离级别的事务在执行普通的`SEELCT`操作时访问记录的版本链的过程。**

    对于读未提交的数据读取因为可以读取未提交事务的数据，直接读取最新的数据就行。对于串行化的数据读取是通过锁实现的。

    在执行insert/update/delete操作时，都会生成一个事务id。select操作的事务id为0。

    **版本链**：每次对数据的插入、更新和删除操作都会记录到undo日志中，聚簇索引的两个隐藏列一个是事务id（记录的当前数据的事务id），一个是回滚指针（指向上一次修改该数据的undo日志），从而将一行数据的修改操作的undo记录建成链表。

    **ReadView**

    * 作用：记录当前查询事务上下文环境的一个逻辑数据结构，用于判断判断版本链中的那个版本的数据是当前事务可见的。

    * ReadView生成的主要内容
        - **事务id列表**：生成ReadView时当前系统中活跃的事务id列表
        - **最小事务id**：生成`ReadView`时当前系统中活跃的读写事务中最小的`事务id`，也就是`m_ids`中的最小值。
        - **最大事务id**：生成`ReadView`时系统中应该分配给下一个事务的`id`值。
        - **生成该ReadView的事务的id**。
    * 判断逻辑
        - 判断在版本链链表中第一个节点的事务id是否在ReadView的事务id列表中
            - 如果在说明当前节点事务还未提交，不能读取该节点数据。
            - 如果不在，
                - 判断当前事务id是否小于ReadView的最小事务id，若小于说明该事务已经提交了，可以读取数据。
                - 判断当前事务id是否大于ReadView的最大事务id，若大于说明当前事务是在生成ReadView之后开启的，不可以读取数据。
                - 判断当前事务d是否大于最小事务id小于最大事务id，如果是则该事务节点的数据可以读取。
    * 读提交和重复读生成ReadView的时机是不同的
        - READ COMMITTED —— 每次读取数据前都生成一个ReadView
            - 读提交事务隔离级别要求一个事务只能读取已经提交的事务的数据。
        - REPEATABLE READ —— 在第一次读取数据时生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。
            - 可重复读的隔离级别要求一个事务在读取数据时，不允许其他事务修改数据，数据是可以重复读取的。

9. ACID的实现原理

    * Atomic
        * 表示组成一个事务中的多个数据库操作是一个不可分割的原子单元，作为原子工作单元执行，要么全部执行，要么全部不执行。
        * 是通过undo日志来实现的。
    * Isolation
        * 如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离。
        * 使用锁和MVCC来实现事务的隔离性。
    * Duration
        * 事务完成后，对数据库数据的修改被持久化存储。
        * MySQL使用redo log和binlog来保证事务的持久性。
    * Consistent
        * 事务完成后，数据库所处的状态与它的业务规则是一致的，即A账户转账100元到B账户，无论成功与否，A账户和B账户的存款总额是不变的。
        * 通过保证原理性、隔离性和持久性，才能保证事务的一致性。